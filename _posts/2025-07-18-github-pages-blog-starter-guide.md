---
title: 초보의 GitHub Pages + Jekyll 블로그 구축기
date: 2025-07-18 04:04:00 +0900
categories: [DevLog]
tags: [Jekyll, blog, github pages]
---
## 도입: 왜 쉬운 길을 두고 어려운 길을 선택했나?

**'개발자 겸 사업가'**가 되겠다는 목표를 세운 후, 나의 생각과 성장 과정을 기록할 공간이 필요했다. 벨로그(Velog)나 티스토리 같은 훌륭한 서비스도 많았지만, 나는 조금 다른 길을 선택했다. 단순히 글을 쓰는 것을 넘어, 내 공간을 내 손으로 직접 구축하고 운영하는 경험 자체가 성장의 일부가 될 것이라 믿었기 때문이다.

그렇게 GitHub Pages와 Jekyll, 그리고 Docker를 이용한 나만의 블로그 만들기는 시작되었다. 이 글은 수많은 오류와 부딪히며 '자동화된 나만의 블로그'를 완성하기까지의 모든 삽질과 해결 과정을 담았다.

## 본문 1: 3개의 세상, 그리고 길을 잃다 (환경 구축과 경로 문제)

먼저 내가 구축한 개발 환경은 세 개의 세상으로 나뉜다.

1.  **GitHub (☁️ 중앙 설계도 & 발행소):** 모든 코드의 최종 버전을 저장하는 **원격 저장소(Remote Repository).** main 브랜치로 push 되면, Actions를 통해 웹사이트를 세상에 발행하는 배포의 출발점이다.
2.  **내 PC (🖥️ 관제실 & 터미널):**  VS Code를 통해 Docker 컨테이너 내부를 들여다보고 제어하는 **사용자 인터페이스(UI).** 사용자의 모든 키보드 입력과 명령이 시작되는 곳이다.
3.  **Docker (🏭 빌드 & 테스트 환경):** 내 PC에 격리되어, Jekyll 등 개발에 필요한 모든 도구가 설치된 실행 환경(Runtime Environment). 소스 코드를 웹사이트로 만드는 **'빌드(Build)'**와 로컬 서버를 통한 **'테스트(Test)'**가 실제로 일어나는 독립된 공간이다.

이 구조는 내 PC를 깨끗하게 유지해주고, 어떤 컴퓨터에서든 동일한 환경에서 작업할 수 있게 해주는 현대적인 방식이다. 하지만 이 구조에 대한 얕은 이해는 곧바로 첫 번째 장벽으로 나를 이끌었다. 바로 **'경로(Path)와의 전쟁'**이었다.

배포는 성공했는데, 사이트의 디자인(CSS)과 이미지가 모두 깨져 보였다. 원인은 `_config.yml` 파일의 `baseurl` 설정 문제였다.

> **문제:** `baseurl`은 무엇이고, 내 블로그에는 어떻게 설정해야 하는가?

GitHub Pages는 리포지토리 이름에 따라 두 종류의 주소를 제공한다.

* **사용자 사이트:** 리포지토리 이름이 `[아이디].github.io`인 경우. 주소는 `https://[아이디].github.io`가 되고, `baseurl`은 `""`(빈 값)이어야 한다.
* **프로젝트 사이트:** 리포지토리 이름이 자유로운 경우(예: `my-blog`). 주소는 `https://[아이디].github.io/my-blog`가 되고, `baseurl`은 `"/my-blog"`여야 한다.

나는 처음에 리포지토리 이름을 `haram.github.io`로 만들었다. 내 아이디는 `intema28`이므로, 이것은 '프로젝트 사이트'로 취급되었다. 결국 모든 경로 문제의 근원을 제거하기 위해, 리포지토리를 삭제하고 **`intema28.github.io`** 라는 이름으로 다시 만들어 `baseurl`을 `""`로 설정하는 '사용자 사이트' 방식으로 전환하여 문제를 해결했다.

## 본문 2: 자동화의 배신과 길들이기 (GitHub Actions 오류)

`git push`만 하면 알아서 웹사이트가 뚝딱 만들어질 거라 기대했던 자동화 로봇(GitHub Actions)은 생각보다 까다로웠다. 내가 겪었던 주요 오류는 다음과 같다.

#### 1. `Get Pages site failed`
* **원인:** 리포지토리 설정에서 "배포는 GitHub Actions가 할 거야"라고 지정해주지 않았기 때문.
* **해결:** **`Settings > Pages > Build and deployment`** 에서 Source를 **`GitHub Actions`**로 변경했다.

#### 2. `Test site failed (exit code 1)`
* **원인:** `htmlproofer`라는 품질 검사 도구가, 아직 글이 없는 내 블로그의 사소한 빈 링크들을 '오류'로 판단했다.
* **해결:** `.github/workflows/` 폴더의 yml 파일에서 `Test site` 부분을 찾아 주석 처리(` # `)하여 검사 단계를 건너뛰었다.

#### 3. `The operation was canceled`
* **원인:** 이전 작업이 채 끝나기도 전에 내가 새로운 `push`를 날려서, 기존 작업이 자동으로 취소된 것. 오류가 아니라 정상 동작이었다.
* **해결:** `Actions` 탭에서 취소된 기록은 무시하고, 가장 마지막에 실행된 워크플로우의 최종 결과만 신뢰하기로 했다.

## 본문 3: 보이지 않는 적, 캐시(Cache)와의 싸움

분명히 파비콘 이미지를 바꿨는데, 로컬 서버에서도, 배포된 사이트에서도 옛날 이미지가 계속 보였다. 이것은 보이지 않는 적인 '캐시' 때문이었다.

* **로컬 서버 문제:** Jekyll이 `_site` 폴더를 만들 때, 이전 빌드의 찌꺼기를 재사용하는 경우가 있었다.
    * **해결:** `bundle exec jekyll clean` 명령어로 `_site` 폴더와 캐시를 강제로 청소한 뒤, 서버를 다시 켜서 해결했다.

* **배포 사이트 문제:** 내 웹 브라우저가 속도를 위해 옛날 이미지 파일을 컴퓨터에 저장해두고 계속 보여주고 있었다.
    * **해결:** `Ctrl + Shift + R` (Mac: `Cmd + Shift + R`) 단축키로 '강력 새로고침'을 실행하여, 브라우저 캐시를 무시하고 서버에서 최신 파일을 강제로 다시 불러와 해결했다.

## 본문 4: 원본을 지키는 안전장치 (Git-Flow 브랜치 전략)

초반에는 모든 작업을 `main`이라는 단 하나의 브랜치에서 진행했다. 작은 실수 하나가 전체 사이트를 망가뜨릴 수 있는 위험천만한 방식이었다. "더 안전하고 체계적인 방법은 없을까?"라는 고민은 나를 **Git-Flow**라는 개념으로 이끌었다.모든 작업을 `main`이라는 단 하나의 브랜치에서 하는 것은, 언제나 라이브로 서비스되는 원본에 직접 칼을 대는 것과 같았다. 작은 실수 하나가 전체 사이트를 망가뜨릴 수 있는 위험한 방식이었다.

이를 해결하기 위해 나는 Git-Flow 전략을 도입했다.

* **`main` 브랜치:** 오직 완벽하게 테스트가 끝난, 최종 발행본만 존재하는 '금고'와 같은 곳이다.
* **`develop` 브랜치:** 앞으로 발행될 모든 개발 내용이 합쳐지는 '중심 작업실'이다.
* **`feature` 브랜치:** `develop`에서 파생된 '나만의 실험실'이다. 새 글을 쓰거나 기능을 추가하는 모든 실제 작업은 이곳에서 이루어진다.

이 구조 덕분에, 나는 `feature` 브랜치에서 마음껏 실험하고 글을 쓸 수 있었다. 작업이 완벽하게 끝나면 `develop`에 합치고, 모든 기능이 모여 안정화되면 그때 비로소 `main`으로 합쳐 발행했다. 이 과정을 통해 원본의 안정성을 항상 유지하면서도, 자유롭게 새로운 시도를 할 수 있는 체계적인 개발 파이프라인을 갖추게 되었다.

이 전략을 실제 작업에 적용한 흐름은 다음과 같았다.

1.  **`feature` 브랜치에서 작업이 끝나면, `develop` 브랜치로 이동해 작업물을 합친다.**
    ```bash
    # develop 브랜치로 이동
    git checkout develop
    
    # 내 작업 브랜치(feature/~)를 develop에 합치기
    git merge feature/~
    
    # 합쳐진 develop 브랜치를 GitHub에 백업
    git push origin develop
    ```

2.  **모든 기능이 모여 발행할 준비가 되면, `main` 브랜치로 최종본을 합친다.**
    ```bash
    # main 브랜치로 이동
    git checkout main
    
    # develop의 모든 내용을 main으로 합치기
    git merge develop
    
    # 최종 발행을 위해 main 브랜치를 GitHub에 push (-> 자동 배포 실행!)
    git push origin main
    ```

## 결론: 이 여정을 통해 내가 얻은 진짜 자산

단순히 블로그 하나를 완성한 것이 아니었다. 이 과정을 통해 나는 현대적인 웹 개발의 전체 흐름을 배웠다.

* **독립적인 개발 환경의 중요성 (Docker)**
* **배포 자동화의 편리함 (CI/CD)**
* **오류 로그를 두려워하지 않고 원인을 찾아 해결하는 능력**
* **안전한 버전 관리 전략 (Git-Flow)**

이 블로그는 이제 나의 지식과 성장을 기록하는 공간이자, '아이디어를 현실로 만드는' 나의 다음 도전을 위한 든든한 자산이 될 것이다.
